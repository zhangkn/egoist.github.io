{"tags":[{"name":"cli","permalink":"https://egoist.moe/tags/cli/","url":"/async/tags/cli.json","count":1},{"name":"node","permalink":"https://egoist.moe/tags/node/","url":"/async/tags/node.json","count":1}],"categories":[],"url":"/async/posts/2017/10/18/how-does-nodejs-cli-program-work.json","date":1508318145000,"path":{"year":2017,"month":10,"day":18,"name":"how-does-nodejs-cli-program-work"},"subtitle":"命令行程序，也就是通过文本在终端中与程序进行交互","title":"Node.js 命令行程序是如何工作的","permalink":"https://egoist.moe/2017/10/18/how-does-nodejs-cli-program-work/","content":"<p>你可能已经知道，在终端里可以调用不同的解释器来执行你的程序，比如:</p>\n<pre><code class=\"language-bash\"># 执行一段 shell 脚本\nsh ./foo.sh\n# 执行一段 node.js 代码\nnode ./bar.js\n</code></pre>\n<p>下一步你想做的可能是省略解释器，直接通过运行 <code>./foo.sh</code> 或者 <code>./bar.js</code> 来执行你的程序。想在命令行输入命令时省略解释器，你可以将它写入实际运行的程序中，比如 <code>./bar.js</code>:</p>\n<pre><code class=\"language-js\">#!/usr/bin/env node\nconsole.log('bar')\n</code></pre>\n<p>这段程序第一行由两部分组成，即 <strong>Shebang</strong> 和 <strong>解释器命令</strong>。<strong>Shebang</strong> 就是开头的 <code>#!</code>，它告诉系统调用后面声明的解释器，而我们需要调用的解释器是 <code>node</code>，执行 <code>/usr/bin/env node</code> 可以寻找到系统 <code>$PATH</code> 里第一个出现的 <code>node</code> 命令。</p>\n<p>这样你便可以通过执行 <code>./bar.js</code> 来执行这段程序了:</p>\n<pre><code class=\"language-bash\">❯ chmod +x bar.js\n❯ ./bar.js\n</code></pre>\n<p>第一行的 <code>chmod +x bar.js</code> 是让系统允许将文件 <code>bar.js</code> 直接作为一段程序运行。现在你可以成功看到期望的输出:</p>\n<p><img src=\"https://i.loli.net/2017/10/18/59e724560f339.png\" alt=\"bar\"></p>\n<h2 id=\"ming-ling-hang-can-shu\">命令行参数</h2>\n<p>在网页应用里，我们依靠 <em>URL</em> 来获得展现页面内容所需要的参数，比如依靠路径 <code>/user/egoist</code> 来获取数据并渲染用户 <code>egoist</code> 的页面。而命令行程序所依靠的便是命令行参数。</p>\n<p>以刚才的 <code>bar.js</code> 为例，假设你需要将 <code>bar</code> 字符串重复 n 次输出，而 n 是用户决定的，你会这样做:</p>\n<pre><code class=\"language-js\">#!/usr/bin/env node\nconst times = process.argv[2] || 1\nconsole.log('bar'.repeat(times))\n</code></pre>\n<p>然后在终端可以看到期望的结果:</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/10/18/59e72774a1ce7.png\" alt=\"process.argv\"></p>\n<p><code>process.argv</code> 是实际执行的命令参数列表(数组)，比如运行 <code>./bar 4</code> 实际执行的是 <code>node ./bar 4</code>，第一个参数是解释器命令 <code>node</code>，第二个是被执行的程序路径。而我们这里只需要第三个参数。</p>\n<hr>\n<p>正如浏览器里的 URL 有相应的各种路由解析库一样，将 <code>/user/egoist</code> 解析成 <code>{ username: 'egoist' }</code> 之类的，命令行参数当然也有，<a href=\"https://github.com/substack/minimist\" target=\"_blank\" rel=\"external\">minimist</a> 便是 node.js 社区里应用最多的一个:</p>\n<pre><code class=\"language-js\">const minimist = require('minimist')\n\n// 大多数情况我们不需要关心 process.argv 的前两项\nconst argv = minimist(process.argv.slice(2))\nconsole.log(argv)\n</code></pre>\n<p>使用不同的命令执行一下这段代码试试:</p>\n<p><img src=\"https://i.loli.net/2017/10/18/59e72c19cea1f.png\" alt=\"minimist\"></p>\n<p>之后你便可以灵活地通过 <code>argv</code> 来判断如何输出用户期望的内容了。</p>\n<p><strong>命令行参数小贴士</strong>:</p>\n<ul>\n<li>形如 <code>--foo</code> 的叫做 <code>switch</code>，也就是代表了一个布尔值 <code>foo: true</code>，后面不加任何值。\n<ul>\n<li>一般用 <code>--no-foo</code> 来表示布尔值 <code>foo: false</code>。</li>\n</ul>\n</li>\n<li>形如 <code>--name egoist</code> 的叫做 <code>flag</code>, 即后面要加值，比如字符串和数字。\n<ul>\n<li>类似的写法是 <code>--name=egoist</code>，用 <code>=</code> 而不是空格来连接。</li>\n</ul>\n</li>\n<li>只有一个连字符的一般用于其它 flag 的简写，比如用 <code>-f</code> 作为 <code>--foo</code> 的简写，使用这两个之中任何一个的效果相同。连字符后面一般是单个字符，而一个连字符加多个字符其实相当于合并了多个简写，比如 <code>-xFd</code> 相当于 <code>-x -F -d</code>。</li>\n<li>某些命令行参数解释器支持用英文小数点 <code>.</code> 连接的参数，比如: <code>--foo.bar baz</code>，解析之后对象 <code>foo</code> 的属性 <code>bar</code> 的值就是 <code>baz</code>。</li>\n</ul>\n<h2 id=\"ming-ling-hang-cheng-xu-kuang-jia\">命令行程序框架</h2>\n<p>类似 web 开发，你当然可以完全从头写你的命令行程序，自己实现一个命令行参数解释器，然后自行判断如何根据参数返回结果。</p>\n<p>不过这有点浪费时间且本末倒置，如果你就是想学习那些方面的内容，你可以那样干，否则如果你只是想为你的一个奇思妙实现一个命令行工具，那就有点得不偿失，不如直接使用现成的框架来加速达成你原本的目标。</p>\n<h3 id=\"kuang-jia-gan-liao-na-xie-shi\">框架干了哪些事</h3>\n<ul>\n<li>根据不同的命令<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup>调用不同的模块。</li>\n<li>自动生成帮助信息，比如执行 <code>git --help</code> 显示的内容。</li>\n<li>让整个程序更安全，比如指定 flag 哪些是必需的。</li>\n<li>自动命令补全。</li>\n</ul>\n<p>在这里我就不过多介绍框架了，毕竟只要了解原理就能举一反三，不过我还是推荐几个常用的，节省读者的时间:</p>\n<ul>\n<li><a href=\"https://github.com/sindresorhus/meow\" target=\"_blank\" rel=\"external\">Meow</a>: 简单的基于 <a href=\"https://github.com/substack/minimist\" target=\"_blank\" rel=\"external\">minimist</a> 的包装，没什么新功能。</li>\n<li><a href=\"https://github.com/tj/commander.js\" target=\"_blank\" rel=\"external\">Commander.js</a>: 功能齐全的框架，提供类似 git 的子命令系统，自动生成帮助信息等。</li>\n<li><strong><a href=\"https://github.com/egoist/cac\" target=\"_blank\" rel=\"external\">CAC</a>: 类似 Commander.js 但更轻巧、现代，支持插件。(我做的)</strong></li>\n<li><a href=\"http://yargs.js.org/\" target=\"_blank\" rel=\"external\">Yargs</a>: 功能强大的框架，但显得过于臃肿。</li>\n</ul>\n<p>这里用 CAC 举个简单的例子，介绍一下如何使用:</p>\n<pre><code class=\"language-js\">// 假设把它放在 cli.js 里\nconst cli = require('cac')()\n\n// 定义一个命令\ncli.command('hi', '打招呼', input =&gt; {\n  console.log(`Hi ${input[0]}`)\n})\n\n// 开始解析 process.argv 并执行相应命令\ncli.parse()\n</code></pre>\n<p>执行 <code>./cli.js</code> 试试:</p>\n<p><img src=\"https://i.loli.net/2017/10/18/59e76be370455.png\" alt=\"cac\"></p>\n<p>如你所见，这里只会在执行 <code>hi</code> 命令之后才会打招呼。</p>\n<p>同时添加 <code>--help</code> flag 会打印出帮助信息:</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/10/18/59e76f8c2d27a.png\" alt=\"help\"></p>\n<h2 id=\"pei-zhi-packagejson\">配置 package.json</h2>\n<p>要想让你的程序的可执行文件全局可用，你需要将其加入到系统 <code>PATH</code> 中，而 npm 简化了这一步骤:</p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;my-cli&quot;,\n  &quot;bin&quot;: &quot;./cli.js&quot;\n}\n</code></pre>\n<p>在本地测试时执行 <code>npm link</code> 或者 <code>npm i -g .</code> 系统便有了 <code>my-cli</code> 命令。</p>\n<p>这里通过配置 <a href=\"https://docs.npmjs.com/files/package.json#bin\" target=\"_blank\" rel=\"external\">bin</a> 让 npm 在安装程序的时候在 <code>{prefix}/bin</code> 目录创建一个<a href=\"https://zh.wikipedia.org/zh-hans/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5\" target=\"_blank\" rel=\"external\">符号链接</a>指向 <code>./cli.js</code> 的绝对路径。在不同的情况下这个 <code>prefix</code> 不同:</p>\n<ul>\n<li>全局安装的模块(即 <code>npm install -g</code>)的 <code>prefix</code> 是执行 <code>npm prefix -g</code> 得到的路径。</li>\n<li>否则将是当前目录里的 <code>./node_modules/.bin</code>。</li>\n</ul>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>这里的命令指程序中的命令，比如 <code>git</code> 程序中有个命令叫 <code>log</code>，你可以通过执行 <code>git log</code> 使用。 <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"}